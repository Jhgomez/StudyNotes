{\rtf1\ansi\ansicpg1252\cocoartf2759
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fmodern\fcharset0 Courier;\f2\fmodern\fcharset0 Courier-Bold;
}
{\colortbl;\red255\green255\blue255;\red191\green100\blue38;\red32\green32\blue32;\red153\green168\blue186;
}
{\*\expandedcolortbl;;\csgenericrgb\c74902\c39216\c14902;\csgenericrgb\c12549\c12549\c12549;\csgenericrgb\c60000\c65882\c72941;
}
\margl1440\margr1440\vieww29400\viewh10820\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\fs36 \cf0 Inline Functions
\fs24 \

\fs28 This feature has to be used with careful since it could lead to more memory usage because when specified in a function the compiler instead of calling and executing the function at runtime it will copy the function call at the call site, you should use this with higher-order functions which are functions that accept other functions which is when we\'92ll mostlikely have a performance gain. This eliminates the overhead of function calls. Use it when a larg\
\
Inline Classes\
\
Kotlin Functions\
They are first class citizens, meaning they can be anywhere, they can be assigned to variables, pass as parameters, pretty much treated as objects. Its possible since all functions return a value which if not define return type is Unit by default.\
\
Higher-order Functions and Lambdas\
As kotlin is a statically typed language(see computer science) and functions are first class citizens, functions can be assigned anywhere as variables, parameters, function return values. Its all possible thanks to the existence of a family of function types to represent functions\
\
	Functions Types\
		They are used by kotlin to represent functions as a data type/object. Example: val funOne: (Int) -> String = \'85 They can have annotations like\
		@composable before the function parameter and also a receiver type so this is equivalent: SomeScope.() -> Unit   equivalent to (SomeScope) -> Unit\
		the previous declaration is similar to an extension function. They can have the suspend before the type. You can give function types a name using type \
		type alias, for example:     typealias custom = (Int, Button) -> Unit The following declaration are equivalent 
\f1\fs26 \cf2 \cb3 fun\cf4 (m: String): String \{ \cf2 return \cf4 m \}\

\f0\fs28 \cf0 \cb1  
\f2\b\fs26 \cf4 \cb3 \{ 
\f1\b0 a: String 
\f2\b -> 
\f1\b0 a 
\f2\b \}
\f0\b0\fs28 \cf0 \cb1 \
	Higher order functions\
		Functions that take functions as parameters or returns a function. \
\
Top Level Functions\
Functions that exists inside a kotlin package but outside any class/object/interface. No need to instantiate an object to call these functions. They are useful for defining helper or utility functions. In java\
these would be static functions inside a helper class. \
\
\
\
Lateinit vs. Lazy\
Lateinit allows us to postpone the initialization of a property until a later time while lazy initializes the property only is first accessed.\
\
Const vs val vs @JvmField\
\
	Const vs val\
	Both define variables which value can not change after they are assigned, however const can only store primitive values, its value has to be defined at compile time(it can only hold strings and primitives) \
	and it can only be defined/declared inside an object or as a top level variable(outside a class/object/interface). val value can be assigned at runtime but only once and it can be declared 	anywhere(class/interface/object/top level)\
	\
	Const vs @JvmField\
	Const characteristics are mentioned above so @JvmField characteristics are: the compiled code will generate a final vairable(constant) It can be declared anywhere(top level/class/object) except interface,\
	what it does is it tells the compiler to expose the variable as a field instead of a property(all class variables are exposed as properties meaning they\'92re automatically generated a getter/setter at compile time),\
	a field doesn\'92t have generated getters or setters and it doesn\'92t have any restriction on the type of object it holds\
\
\
\
\
\
\
\
}